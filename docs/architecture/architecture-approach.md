# Архитектурный подход проекта `cian-rental-bot`

## 1) Цели архитектуры

- Предсказуемая и расширяемая модульная структура для Telegram-бота.
- Четкое разделение ответственности между обработкой Telegram-событий, бизнес-правилами, парсингом источника и хранением состояния.
- Безопасная эволюция: новые функции добавляются без каскадных изменений по всему коду.

## 2) Базовая архитектура (фактическая и целевая)

Проект использует слоистую модульную архитектуру в `src/`:

- `src/bot`: presentation-слой (`handlers`, `keyboards`, `formatter`).
- `src/parser`: интеграция с внешним источником и преобразование данных.
- `src/storage`: слой доступа к данным (SQLite через `aiosqlite`).
- `src/scheduler`: оркестрация периодических задач мониторинга.
- `src/main.py`: composition root (сборка зависимостей и запуск runtime).

Целевой поток данных:

1. Пользователь взаимодействует с `handlers`.
2. Фильтры сохраняются в `storage`.
3. Планировщик запускает `scheduler.monitor`.
4. `monitor` вызывает `parser` для получения объявлений.
5. Объявления фильтруются по `UserFilter.matches`.
6. Новые объявления отправляются в Telegram и помечаются как `seen`.

## 3) Архитектурные инварианты

1. Все I/O операции только через `async/await` (Telegram API, HTTP, БД).
2. `main.py` содержит только сборку приложения и запуск, без бизнес-логики.
3. `bot` не должен напрямую работать с SQL и HTTP.
4. `storage` не зависит от `bot` и Telegram-типа данных.
5. Отправка уведомлений должна быть идемпотентной через `seen_listings`.
6. Ошибки логируются с контекстом, а не подавляются без трассировки.

## 4) Правила зависимостей между модулями

- Разрешено:
  - `main -> bot|scheduler|storage|config`
  - `scheduler -> parser|storage|bot.formatter`
  - `bot -> parser.models|storage (через DI)`
  - `storage -> parser.models`
- Запрещено:
  - `parser -> bot|scheduler|storage`
  - `storage -> bot|scheduler`
  - Вызовы Telegram API вне `bot` и `scheduler` без отдельного adapter-слоя.

## 5) Архитектурные неточности: решение о допустимости

Ниже перечислены обнаруженные отклонения с решением: допустимо ли оставлять их в текущем контексте.

### 5.1 Недопустимые неточности (нужно исправлять)

1. Широкий `except Exception` в `src/scheduler/monitor.py`.
   - Почему недопустимо: скрывает классы ошибок и усложняет эксплуатацию.
   - Риск: потеря сигналов о системных дефектах, рост MTTR.
   - Политика: оставлять только на границе джоба с обязательной структурированной диагностикой и последующей декомпозицией по типам исключений.

2. Множественные `# type: ignore` в `src/bot/handlers.py`.
   - Почему недопустимо: ослабляет гарантии типобезопасности в критичном пользовательском потоке.
   - Риск: silent runtime-ошибки при неожиданных `None` в `message`/`from_user`.
   - Политика: заменить на явные runtime-проверки и/или helper-функции с корректной типизацией.

3. Отсутствие явного service/use-case слоя между `handlers` и бизнес-логикой фильтров.
   - Почему недопустимо: утяжеляет presentation-слой и повышает связность.
   - Риск: сложная поддержка сценариев и рост дублирования.
   - Политика: вынести операции сценариев (подтверждение фильтра, запуск/пауза, валидация payload) в отдельный модуль `src/services`.

### 5.2 Допустимые неточности (можно оставить при условиях)

1. `MemoryStorage` для FSM в `src/main.py`.
   - Допустимо, если: один инстанс процесса, без требований к горизонтальному масштабированию и восстановлению FSM-состояния после рестарта.
   - Условие пересмотра: запуск второго инстанса или требование HA.
   - План миграции: переход на Redis storage для aiogram FSM.

2. SQLite как основная БД.
   - Допустимо, если: умеренная нагрузка, один writer-процесс, локальный deployment.
   - Условие пересмотра: рост конкурирующих записей/пользователей, требования к репликации и сложной аналитике.
   - План миграции: переход на PostgreSQL + миграции.

3. Порог покрытия `--cov-fail-under=40`.
   - Допустимо, если: проект в стадии активного формирования и ведется приоритизация тестов критических путей.
   - Условие пересмотра: стабилизация фич и выход на production-SLA.
   - План миграции: поднять порог до 60+, затем 75+ поэтапно.

4. Хардкод ограниченного списка городов в клавиатурах.
   - Допустимо, если: продукт ограничен Москвой и Санкт-Петербургом.
   - Условие пересмотра: запуск мульти-регионального сценария.
   - План миграции: конфигурируемый справочник городов (env/БД/remote config).

## 6) Нефункциональные требования и quality gates

- Логирование:
  - Каждая ошибка содержит контекст `user_id`, `cian_id` (если есть), этап обработки.
- Надежность:
  - Сетевые операции предусматривают retry/backoff (минимум в parser-слое).
- Тестирование:
  - Unit-тесты: `parser.models`, formatter, helper-валидации.
  - Интеграционные: `storage` и сценарий мониторинга с моками Telegram/HTTP.
  - Регрессии: тесты на callback payload и анти-спам rate-limit.

## 7) Принципы развития архитектуры

1. Новая функция начинается с определения слоя ответственности.
2. Любой новый внешний I/O добавляется через отдельный adapter/client.
3. Изменения в `handlers` должны быть thin-controller стилем.
4. Любая временная неточность фиксируется документально: причина, срок, триггер пересмотра.
